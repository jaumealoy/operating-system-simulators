{
    "common": {
        "close": "Cerrar",
        "buttons": {
            "simpleview": "Vista simple",
            "comparaisonview": "Vista comparativa",
            "tutorial": "Tutorial",
            "previous_step": "Paso anterior",
            "next_step": "Siguiente paso",
            "reset": "Borrar datos",
            "pause": "Pausar",
            "play": "Iniciar",
            "stop": "Reiniciar simulación",
            "load_file": "Cargar simulación",
            "save_file": "Guardar simulación",
            "add": "Añadir"
        },
        "example_number": "Ejemplo {{number}}",
        "examples": "Ejemplos",
        "simulation_algorithm": "Algoritmo simulación",
        "simulator_settings": "Configuración del simulador",
        "tutorial": {
            "control_bar_overview": "Esto es la barra de control del simulador que te permite controlar la simulación.",
            "control_bar_reset": "Este botón reinicia el simulador: elimina todas las peticiones.",
            "control_bar_stop": "Este botón reinicia la simulación, sin eliminar las peticiones.",
            "control_bar_previous_step": "Este botón permite volver al estado anterior de la simulación",
            "control_bar_next_step": "Este botón avanza en un paso la simulación, permite ver la simulación paso a paso.",
            "control_bar_play": "Este botón permite iniciar o parar la simulación automática.",
            "control_bar_speed": "Puedes ajustar la velocidad de la simulación automática con esta barra",
            "view_bar": "Puedes cambiar entre una vista de un solo simulador y una vista de múltiples simuladores para realizar comparaciones.",
            "storage": "Puedes guardar y cargar las configuraciones de tu simulador.",
            "repeat_tutorial": "Puedes volver a ver este tutorial en cualquier momento pulsándome."
        }
    },

    "io": {
        "requests": "Peticiones",
        "add_request": "Añadir petición",
        "no_requests_added": "No se ha introducido ninguna petición.",
        "track": "Pista",
        "direction": "Sentido",
        "upwards": "Ascendente",
        "downwards": "Descentende",
        "initial_position": "Posición inicial",
        "final_position": "Posición final",
        "track_number": "Número de pistas",
        "request_number": "# petición",
        "displacement": "Desplazamiento",
        "results": "Resultados",
        "total": "Total",
        "no_requests_completed": "No se ha completado ninguna petición",
        "algorithms": {
            "fcfs": "First Come First Served (FCFS)",
            "sstf": "Shortest Seek Time First (SSTF)",
            "scan": "SCAN",
            "cscan": "CSCAN",
            "look": "LOOK",
            "clook": "CLOOK"
        },

        "tutorial": {
            "algorithm_select": "Aquí puedes seleccionar el algoritmo de la simulación. Si estás en la vista comparativa podrás seleccionar más de uno.",
            "simulator_settings": "Puedes configurar el número de pistas y posición inicial del cabezal. También se puede indicar el sentido inicial del movimiento, si los algoritmos seleccionados lo permiten.",
            "request_list": "Aquí puedes indicar las peticiones que quieres simular y observar las peticiones que se procesarán",
            "request_list_add": "Para añadir una petición debes introducir un valor numérico entre {{min}} y {{max}} y pulsar el botón \"Añadir petición\".",
            "request_list_remove": "Aquí aparecen todas las peticiones así como las has introducido. Puedes borrarlas haciendo click en el icono con una \"X\"",
            "demo_requests": "El simulador ya incluye algunos ejemplos de peticiones para observar el funcionamiento de éste. Si pulsas sobre algún ejemplo se añadirán automáticamente las peticiones."
        }
    },

    "cpu": {
        "algorithms": {
            "fifo": "First In First Out (FIFO, FCFS)",
            "spn": "Shortest Process Next (SPN)",
            "srtn": "Shortest Remaining Time (SRT)",
            "hrrn": "Highest Response Ratio Next (HRRN)",
            "feedback": "Feedback",
            "rr": "Round Robin"
        },

        "quantum": "Quantum",
        "add_process": "Añadir proceso",
        "processes": "Procesos",
        "introduced_processes": "Procesos introducidos",
        "results": "Resultados",
        "timeline": "Línea temporal",
        "cpu": "Procesador",
        "no_process_running": "Actualmente no hay ningún proceso en ejecución.",
        "name": "Nombre",
        "cycle_distribution": "Distribución",
        "cycle_distribution_form": "Distribución de los ciclos",
        "incoming_processes": "Llegada de procesos",
        "remaining_cycles": "Ciclos restantes",
        "waiting_cycles": "Ciclos esperando",
        "waiting_time": "Tiempo esperando",
        "blocked": "Bloqueados",
        "ready": "Listos",
        "priority_number": "Prioridad {{value}}",
        "schedule_summary": "Resumen planificación",
        "process_already_exists": "Ya existe un proceso con este nombre",
        "arrival": "Llegada",
        "duration": "Ciclos",
        "value_equal_or_higher_than": "El valor debe ser igual o superior a {{value}}",
        "maximum_queues": "Máximo de colas",
        "zero_is_unlimited": "El valor 0 indica ilimitado",
        "fixed": "Fijo",
        "add_variant": "Añadir configuración",
        "process_list_empty": "No has introducido ninguna petición",
        "queue_empty": "No hay procesos en esta cola",
        "variant_tag": {
            "unlimited_queues": "ilimitadas",
            "value_max_queues": "{{value}} colas"
        },
        "ratio": "Ratio",
        "summary": {
            "start": "Inicio",
            "end": "Finalización",
            "process": "Proceso",
            "service_time": "Tiempo de servicio",
            "turnaround_time": "Tiempo de retorno",
            "response_time": "Tiempo de respuesta",
            "normalized_response_time": "Tiempo de respuesta normalizado"
        },
        "tutorial": {
            "process_list": "Aquí puedes ver y eliminar los procesos que has introducido. Puedes ver su ciclo de llegada y su distribución de ciclos.",
            "summary_table": "Esta tabla muestra un resumen de la planificación de procesador. Cada fila es un proceso e indica información sobre su ejecución (llegada, finalización, tiempo de respuesta y de retorno).",
            "process_queues": "En el modo simple puedes ver en todo momento el estado de las colas. Los procesos están ordenados por orden de llegada: los elementos de arriba son los que han llegado primero.",
            "time_chart": "Este diagrama temporal muestra el estado del procesos (en ejecución o bloqueado) en cada ciclo de procesador.",
            "current_process": "También se muestra el estado actual del procesador y se muestra información del proceso en ejecución."
        }
    },

    "menu": {
        "IOSimulator": "Simulador E/S",
        "CPUSimulator": "Simulador CPU",
        "FAQ": "Ayuda"
    },

    "help": {
        "modals": {
            "io": {
                "fcfs": {
                    "text_1": "El algoritmo First Come First Served procesa los accesos a disco secuencialment. La primera petición que se recibe es la primera petición procesada.",
                    "text_2": "Al realizarse muchas peticiones, este algoritmo se comporta como una planificación aleatoria, aunque es el sistema más justo de todos."
                }
            },

            "cpu": {
                "fifo": {
                    "text_1": "El algoritmo First In First Out (FIFO), también conocido como First Come First Served (FCFS) o “primero en llegar, primero servirse”, es la política de planificación más simple.",
                    "text_2": "Esta política planificación consiste en ejecutar los procesos en el mismo orden que llegan a la cola de procesos listos.",
                    "text_3": "Así, si un proceso en ejecución queda bloqueado por E/S, cuando finalice la E/S, será el último de la cola de procesos listos y por tanto, el último en ejecutarse.",
                    "text_4": "Este algoritmo facilita la ejecución de procesos de larga duración y favorece aquellos limitados por el procesador."
                },

                "spn": {
                    "text_1": "El algoritmo Shortest Process Next (SPN) o “primero el más corto” es una política de planificación que consiste en ejecutar el proceso que se espera que sea más corto.",
                    "text_2": "Algunos inconvenientes de esta política es la necesidad de poder estimar la duración del proceso y la posible inanición de los procesos más largos que será menos prioritarios frente los procesos cortos.",
                    "text_3": "En el simulador, el valor de la estimación es el número de ciclos del proceso."
                },

                "srtn": {
                    "text_1": "El algoritmo Shortest Remaining Time (SRT) es la versión apropiativa del algoritmo SPN que consiste en ejecutar el proceso con un tiempo restante de ejecución menor.",
                    "text_2": "El tiempo restante de un proceso se puede calcular a partir del número de ciclos que ha sido ejecutado y el tiempo de servicio, o en su defecto su estimación, del proceso.",
                    "text_3": "Este sistema de planificación puede producir inanición y favorece los procesos cortos frente a los procesos más largos."
                },

                "hrrn": {
                    "text_1": "El algoritmo Highest Response Ratio Next (HRRN) o “primero el de mayor tasa de respuesta” es un algoritmo no apropiativo que ejecuta el proceso con la mayor tasa de respuesta.",
                    "text_2": "Para cada uno de los procesos en la cola de listos se calcula su tasa de respuesta siguiendo la siguiente fórmula:",
                    "text_3": "Y se selecciona el proceso que maximice este resultado.",
                    "text_4": "En un principio favorece los procesos cortos, pero evita la inanición de los procesos largos porque se tiene en cuenta su tiempo de espera."
                }, 

                "rr": {
                    "text_1": "El algoritmo Round Robin o turno rotatorio es un algoritmo apropiativo basado en un reloj. Los procesos reciben un tiempo limitado, conocido como quantum, de procesador de manera rotatoria hasta que finalizan. Si los procesos han consumido el tiempo asignado y no han finalizado, son expulsados y vuelven a situarse al final de la cola de procesos listos.",
                    "text_2": "Los principales inconvenientes de este sistema son fijar una rodaja de tiempo adecuada, el bajo rendimiento de los procesos limitados por E/S y la sobrecarga que supone cambiar de proceso."
                },

                "feedback": {
                    "text_1": "El algoritmo Feedback o retroalimentación es un sistema apropiativo que hace uso de un sistema de colas de prioridad dinámica y un sistema de rodajas de tiempo. ",
                    "text_2": "Los procesos empiezan en la cola de máxima prioridad y cuando finaliza su rodaja de tiempo (y no han finalizado)  o quedan bloqueados por E/S pasan a la siguiente cola de menor prioridad.",
                    "text_3_1": "Por ejemplo, es habitual que la rodaja de tiempo sea una potencia de 2 de la forma ",
                    "text_3_2": ", donde i es la prioridad de la cola (i=0 es la cola más prioritaria).",
                    "text_4": "Este sistema da preferencia a los procesos cortos y penaliza los procesos largos que han estado mucho tiempo en ejecución, ya que se encuentran en colas de baja prioridad."
                }

            }
        }
    }
}