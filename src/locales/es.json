{
    "common": {
        "close": "Cerrar",
        "buttons": {
            "simpleview": "Vista simple",
            "comparaisonview": "Vista comparativa",
            "tutorial": "Tutorial",
            "previous_step": "Paso anterior",
            "next_step": "Siguiente paso",
            "reset": "Borrar datos",
            "pause": "Pausar",
            "play": "Iniciar",
            "stop": "Reiniciar simulación",
            "load_file": "Cargar simulación",
            "save_file": "Guardar simulación",
            "add": "Añadir"
        },
        "example_number": "Ejemplo {{number}}",
        "examples": "Ejemplos",
        "simulation_algorithm": "Algoritmo simulación",
        "simulator_settings": "Configuración del simulador",
        "simulator_results": "Resultados",
        "tutorial": {
            "control_bar_overview": "Esto es la barra de control del simulador que te permite controlar la simulación.",
            "control_bar_reset": "Este botón reinicia el simulador: elimina todas las peticiones.",
            "control_bar_stop": "Este botón reinicia la simulación, sin eliminar las peticiones.",
            "control_bar_previous_step": "Este botón permite volver al estado anterior de la simulación",
            "control_bar_next_step": "Este botón avanza en un paso la simulación, permite ver la simulación paso a paso.",
            "control_bar_play": "Este botón permite iniciar o parar la simulación automática.",
            "control_bar_speed": "Puedes ajustar la velocidad de la simulación automática con esta barra",
            "view_bar": "Puedes cambiar entre una vista de un solo simulador y una vista de múltiples simuladores para realizar comparaciones.",
            "storage": "Puedes guardar y cargar las configuraciones de tu simulador.",
            "repeat_tutorial": "Puedes volver a ver este tutorial en cualquier momento pulsándome."
        }
    },

    "io": {
        "requests": "Peticiones",
        "add_request": "Añadir petición",
        "no_requests_added": "No se ha introducido ninguna petición.",
        "track": "Pista",
        "direction": "Sentido",
        "upwards": "Ascendente",
        "downwards": "Descentende",
        "initial_position": "Posición inicial",
        "final_position": "Posición final",
        "track_number": "Número de pistas",
        "request_number": "# petición",
        "displacement": "Desplazamiento",
        "results": "Resultados",
        "total": "Total",
        "average": "Media",
        "no_requests_completed": "No se ha completado ninguna petición",
        "algorithms": {
            "fcfs": "First Come First Served (FCFS)",
            "sstf": "Shortest Seek Time First (SSTF)",
            "scan": "SCAN",
            "cscan": "CSCAN",
            "look": "LOOK",
            "clook": "CLOOK"
        },

        "tutorial": {
            "algorithm_select": "Aquí puedes seleccionar el algoritmo de la simulación. Si estás en la vista comparativa podrás seleccionar más de uno.",
            "simulator_settings": "Puedes configurar el número de pistas y posición inicial del cabezal. También se puede indicar el sentido inicial del movimiento, si los algoritmos seleccionados lo permiten.",
            "request_list": "Aquí puedes indicar las peticiones que quieres simular y observar las peticiones que se procesarán",
            "request_list_add": "Para añadir una petición debes introducir un valor numérico entre {{min}} y {{max}} y pulsar el botón \"Añadir petición\".",
            "request_list_remove": "Aquí aparecen todas las peticiones así como las has introducido. Puedes borrarlas haciendo click en el icono con una \"X\"",
            "demo_requests": "El simulador ya incluye algunos ejemplos de peticiones para observar el funcionamiento de éste. Si pulsas sobre algún ejemplo se añadirán automáticamente las peticiones."
        }
    },

    "cpu": {
        "algorithms": {
            "fifo": "First In First Out (FIFO, FCFS)",
            "spn": "Shortest Process Next (SPN)",
            "srtn": "Shortest Remaining Time (SRT)",
            "hrrn": "Highest Response Ratio Next (HRRN)",
            "feedback": "Feedback",
            "rr": "Round Robin"
        },

        "quantum": "Quantum",
        "add_process": "Añadir proceso",
        "processes": "Procesos",
        "introduced_processes": "Procesos introducidos",
        "results": "Resultados",
        "timeline": "Línea temporal",
        "cpu": "Procesador",
        "no_process_running": "Actualmente no hay ningún proceso en ejecución.",
        "name": "Nombre",
        "cycle_distribution": "Distribución",
        "cycle_distribution_form": "Distribución de los ciclos",
        "incoming_processes": "Llegada de procesos",
        "remaining_cycles": "Ciclos restantes",
        "waiting_cycles": "Ciclos esperando",
        "waiting_time": "Tiempo esperando",
        "blocked": "Bloqueados",
        "ready": "Listos",
        "priority_number": "Prioridad {{value}}",
        "schedule_summary": "Resumen planificación",
        "process_already_exists": "Ya existe un proceso con este nombre",
        "arrival": "Llegada",
        "duration": "Ciclos",
        "value_equal_or_higher_than": "El valor debe ser igual o superior a {{value}}",
        "maximum_queues": "Máximo de colas",
        "zero_is_unlimited": "El valor 0 indica ilimitado",
        "fixed": "Fijo",
        "add_variant": "Añadir configuración",
        "process_list_empty": "No has introducido ninguna petición",
        "queue_empty": "No hay procesos en esta cola",
        "average": "Media",
        "variant_tag": {
            "unlimited_queues": "ilimitadas",
            "value_max_queues": "{{value}} colas"
        },
        "ratio": "Ratio",
        "summary": {
            "start": "Inicio",
            "end": "Finalización",
            "process": "Proceso",
            "service_time": "Tiempo de servicio",
            "turnaround_time": "Tiempo de retorno",
            "response_time": "Tiempo de respuesta",
            "normalized_response_time": "Tiempo de respuesta normalizado"
        },
        "tutorial": {
            "process_list": "Aquí puedes ver y eliminar los procesos que has introducido. Puedes ver su ciclo de llegada y su distribución de ciclos.",
            "summary_table": "Esta tabla muestra un resumen de la planificación de procesador. Cada fila es un proceso e indica información sobre su ejecución (llegada, finalización, tiempo de respuesta y de retorno).",
            "process_queues": "En el modo simple puedes ver en todo momento el estado de las colas. Los procesos están ordenados por orden de llegada: los elementos de arriba son los que han llegado primero.",
            "time_chart": "Este diagrama temporal muestra el estado del procesos (en ejecución o bloqueado) en cada ciclo de procesador.",
            "current_process": "También se muestra el estado actual del procesador y se muestra información del proceso en ejecución."
        }
    },

    "memory": {
        "allocation_menu": "Asignación de memoria",
        "pagination_menu": "Paginación",

        "allocation": {
            "capacity": "Capacidad",
            "current_cycle": "Ciclo actual:",
            "next_requests": "Próximas peticiones:",
            "process": "Proceso",
            "duration": "Duración",
            "requested_memory": "Memoria solicitada",
            "permanent": "permanente",
            "not_enough_memory": "No hay memoria suficiente",
            "no_more_requests": "No hay más peticiones de memoria",
            "no_requests_completed": "No se ha atendido ninguna petición de memoria",
            "no_requests_added": "No se han añadido peticiones.",
            "completed_requests": "Peticiones de memoria atendidas:",
            "assigned_block": "Bloque asignado",
            "cycle": "Ciclo",
            "memory": "Memoria",

            "algorithms": {
                "first_fit": "Primer ajuste (First fit)",
                "next_fit": "Siguiente ajuste (Next fit)",
                "worst_fit": "Peor ajuste (Worst fit)",
                "best_fit": "Mejor ajuste (Best fit)",
                "buddy": "Sistema de colegas (Buddy system)"
            }
        },

        "pagination": {
            "frames": "Marcos",
            "frame": "Marco",
            "processes_pages": "Páginas y procesos",
            "page_failures": "Fallos de página",
            "process_name": "Process {{name}}",
            "page": "Página",
            "last_access": "Último acceso",
            "select_algorithm": "Selecciona un algoritmo o más para utilizar la vista comparativa",
            "write": "Escritura",
            "added_requests": "Peticiones introducidas",
            "name_frames": "Nombre y marcos",
            "no_processes": "No has introducido ningún proceso",

            "algorithms": {
                "optimal": "Óptimo",
                "fifo": "First In First Out",
                "lru": "Least Recently Used",
                "clock": "Reloj",
                "nru": "Not Recently Used"
            }
        }
    },

    "menu": {
        "IOSimulator": "Simulador E/S",
        "CPUSimulator": "Simulador CPU",
        "MemorySimulator": "Simulador memoria",
        "FAQ": "Ayuda"
    },

    "help": {
        "modals": {
            "io": {
                "fcfs": {
                    "text_1": "El algoritmo First Come First Served procesa los accesos a disco secuencialment. La primera petición que se recibe es la primera petición procesada.",
                    "text_2": "Al realizarse muchas peticiones, este algoritmo se comporta como una planificación aleatoria, aunque es el sistema más justo de todos."
                },

                "sstf": {
                    "text_1": "El algoritmo Shortest Seek Time First conocido como “primero con el tiempo de búsqueda menor” atiende primero aquellas peticiones que se encuentran más cerca del cabezal.",
                    "text_2": "Este sistema favorece las peticiones que se encuentran cerca del cabezal, desfavoreciendo las peticiones periféricas."
                },

                "scan": {
                    "text_1": "El algoritmo SCAN intenta simular el comportamiento de un ascensor. El cabezal se mueve desde la primera pista, aunque no haya peticiones, hasta la última procesando las peticiones que se encuentra. Cuando llega a un extremo, realiza el mismo recorrido en sentido contrario.",
                    "text_2": "El objetivo del algoritmo es reducir los cambios de sentido, pero favorece a las peticiones recientes."
                },

                "cscan": {
                    "text_1": "El algoritmo C-SCAN intenta simular el comportamiento de un ascensor como el algoritmo SCAN. El cabezal se mueve en un único sentido (ascendente o descendente) y cuando llega a un extremo se sitúa rápidamente al contrario sin atender peticiones.",
                    "text_2": "El principal objetivo es eliminar la discriminación entre las pistas interiores y las periféricas."
                },

                "look": {
                    "text_1": "El algoritmo LOOK simula el comportamiento de un ascensor. Este algoritmo procesa todas las peticiones que se encuentra en un sentido hasta llegar a la última pista. Luego realiza el mismo recorrido pero en sentido contrario hasta llegar a la última petición, sin llegar al extremo del disco.",
                    "text_2": "La principal diferencia entre LOOK y SCAN es que el primero no llega hasta los límites del disco, en cambio, SCAN sí."
                },

                "clook": {
                    "text_1": "El algoritmo C-LOOK tiene un comportamiento similar al LOOK. Este algoritmo siempre atiende todas las peticiones que se encuentra en un sentido, y siempre es el mismo. A diferencia del C-SCAN, éste no llega a los extremos del disco, solo hasta la pista con peticiones."
                }
            },

            "cpu": {
                "fifo": {
                    "text_1": "El algoritmo First In First Out (FIFO), también conocido como First Come First Served (FCFS) o “primero en llegar, primero servirse”, es la política de planificación más simple.",
                    "text_2": "Esta política planificación consiste en ejecutar los procesos en el mismo orden que llegan a la cola de procesos listos.",
                    "text_3": "Así, si un proceso en ejecución queda bloqueado por E/S, cuando finalice la E/S, será el último de la cola de procesos listos y por tanto, el último en ejecutarse.",
                    "text_4": "Este algoritmo facilita la ejecución de procesos de larga duración y favorece aquellos limitados por el procesador."
                },

                "spn": {
                    "text_1": "El algoritmo Shortest Process Next (SPN) o “primero el más corto” es una política de planificación que consiste en ejecutar el proceso que se espera que sea más corto.",
                    "text_2": "Algunos inconvenientes de esta política es la necesidad de poder estimar la duración del proceso y la posible inanición de los procesos más largos que será menos prioritarios frente los procesos cortos.",
                    "text_3": "En el simulador, el valor de la estimación es el número de ciclos del proceso."
                },

                "srtn": {
                    "text_1": "El algoritmo Shortest Remaining Time (SRT) es la versión apropiativa del algoritmo SPN que consiste en ejecutar el proceso con un tiempo restante de ejecución menor.",
                    "text_2": "El tiempo restante de un proceso se puede calcular a partir del número de ciclos que ha sido ejecutado y el tiempo de servicio, o en su defecto su estimación, del proceso.",
                    "text_3": "Este sistema de planificación puede producir inanición y favorece los procesos cortos frente a los procesos más largos."
                },

                "hrrn": {
                    "text_1": "El algoritmo Highest Response Ratio Next (HRRN) o “primero el de mayor tasa de respuesta” es un algoritmo no apropiativo que ejecuta el proceso con la mayor tasa de respuesta.",
                    "text_2": "Para cada uno de los procesos en la cola de listos se calcula su tasa de respuesta siguiendo la siguiente fórmula:",
                    "text_3": "Y se selecciona el proceso que maximice este resultado.",
                    "text_4": "En un principio favorece los procesos cortos, pero evita la inanición de los procesos largos porque se tiene en cuenta su tiempo de espera."
                }, 

                "rr": {
                    "text_1": "El algoritmo Round Robin o turno rotatorio es un algoritmo apropiativo basado en un reloj. Los procesos reciben un tiempo limitado, conocido como quantum, de procesador de manera rotatoria hasta que finalizan. Si los procesos han consumido el tiempo asignado y no han finalizado, son expulsados y vuelven a situarse al final de la cola de procesos listos.",
                    "text_2": "Los principales inconvenientes de este sistema son fijar una rodaja de tiempo adecuada, el bajo rendimiento de los procesos limitados por E/S y la sobrecarga que supone cambiar de proceso."
                },

                "feedback": {
                    "text_1": "El algoritmo Feedback o retroalimentación es un sistema apropiativo que hace uso de un sistema de colas de prioridad dinámica y un sistema de rodajas de tiempo. ",
                    "text_2": "Los procesos empiezan en la cola de máxima prioridad y cuando finaliza su rodaja de tiempo (y no han finalizado)  o quedan bloqueados por E/S pasan a la siguiente cola de menor prioridad.",
                    "text_3_1": "Por ejemplo, es habitual que la rodaja de tiempo sea una potencia de 2 de la forma ",
                    "text_3_2": ", donde i es la prioridad de la cola (i=0 es la cola más prioritaria).",
                    "text_4": "Este sistema da preferencia a los procesos cortos y penaliza los procesos largos que han estado mucho tiempo en ejecución, ya que se encuentran en colas de baja prioridad."
                }

            },

            "memory": {
                "allocation": {
                    "first_fit": {
                        "text_1": "El algoritmo First Fit o Primer ajuste asigna la primera partición disponible con la capacidad suficiente para almacenar el proceso, sin buscar si existen otros bloques de memoria más adecuados para la cantidad de memoria solicitada.",
                        "text_2": "Este sistema es el más rápido y sencillo que permite tener muchos procesos cargados al inicio de memoria entre los que se ha de encontrar un bloque libre."
                    },

                    "best_fit": {
                        "text_1": "El algoritmo Best Fit o Mejor ajuste asigna la partición más pequeña con capacidad suficiente para almacenar el proceso.",
                        "text_2": "El rendimiento global de este sistema no es tan bueno como el de otros sistemas y provoca mucha fragmentación externa, haciendo necesario compactar la memoria frecuentemente."
                    },

                    "next_fit": {
                        "text_1": "El algoritmo Next fit o Siguiente ajuste asigna el siguiente bloque de memoria con capacidad para almacenar el proceso a partir del último bloque de memoria asignado.",
                        "text_2": "Este sistema provoca fragmentación externa porqué el mayor bloque de memoria se encuentra al final de la memoria y éste se divide rápidamente en bloques más pequeños.",
                        "text_3": "Para su implementación, es necesario almacenar la posición del último bloque asignado."
                    },

                    "worst_fit": {
                        "text_1": "El algoritmo Worst fit o Peor ajuste asigna el mayor bloque de memoria con capacidad para el proceso con la intención de reducir la fragmentación."
                    },

                    "buddy": {
                        "text_1": "El sistema de colegas intenta lograr un equilibrio entre los sistemas de particiones fijas y los sistemas de particiones variables. Este sistema solo permite crear bloques de memoria de capacidad igual a una potencia en base 2.",
                        "text_2": "En un instante inicial, la memoria forma un único bloque de memoria, pero se puede ir dividiendo entre 2 para atender una petición de memoria. Los procesos ocupan un bloque de memoria óptimo, que es aquel con la capacidad mínima necesaria.",
                        "text_3": "Cuando se libera un bloque, el bloque liberado se puede fusionar con los bloques adyacentes siempre que sean descendentes del mismo bloque de potencia superior."
                    }
                },

                "pagination": {
                    "optimal": {
                        "text_1": "El algoritmo óptimo o mínimo es un algoritmo teórico que minimiza los fallos de página. Este algoritmo remplaza la página de un proceso que estará más tiempo en ser referenciada.",
                        "text_2": "En la práctica, es imposible de implementar ya que supondría conocer de antemano las páginas que van a ser referenciadas, cosa que no es posible."
                    },

                    "fifo": {
                        "text_1": "El algoritmo FIFO o \"primero en llegar primero en irse\" es un algoritmo que selecciona la página que más tiempo ha estado residiendo en la memoria, es decir, la página que ha llegado primero.",
                        "text_2": "Este algoritmo es fácil de implementar, pero hace un uso pobre de la localidad temporal, ya que es posible que una página se utilice frecuentemente y sea la primera en cargarse.",
                        "text_3": "Es posible pensar que si se aumentan el número de marcos asignados a cada proceso se reducirán el número de fallos de página. La anomalía de Belady explica que es posible que el número de fallos de página aumente si se incrementan el número de marcos asignados a cada proceso."
                    },

                    "lru": {
                        "text_1": "El algoritmo Least Recently Used (LRU) o \"menos usado recientemente\" hace uso del principio de localidad espacial para remplazar una página. La página remplazada es la que no ha sido referenciada desde hace más tiempo, que es la página que tiene menor probabilidad de ser referenciada en el futuro cercano.",
                        "text_2": "Este algoritmo se aproxima al algoritmo óptimo y es el que menos fallos de página genera. Para implementarlo es necesario etiquetar cada página en el instante en que es referenciada."
                    },

                    "clock": {
                        "text_1": "El algoritmo del reloj o de la segunda oportunidad intenta aprovechar el principio de temporalidad para elegir la página remplazada. Esto permite tener páginas muy utilizadas que han estado en la memoria durante mucho tiempo.",
                        "text_2": "Para implementar este algoritmo es necesario introducir un bit de acceso a la página, que se activa cuando se referencia una página, y un puntero, que indica la página candidata a ser eliminada. Cuando se quiere remplazar una página pueden darse dos casos:",
                        "text_2_1": "El puntero se encuentra en una página con el bit de acceso a 0. La página eliminada es la indicada por el puntero y se avanza el puntero.",
                        "text_2_2": "El puntero se encuentra en una página con el bit de acceso a 1. En este caso, se desactiva el bit de acceso y se avanza el puntero. El proceso se repite hasta encontrar una página con el bit de acceso a 0."
                    },

                    "nru": {
                        "text_1": "El algoritmo Not Recently Used o \"no usados recientemente\" es una mejora del algoritmo del reloj que hace uso del bit de escritura para evitar remplazar que requieren escritura en la memoria secundaria.",
                        "text_2": "Para su implementación, además de los bits de acceso y modificación, se hace uso de un puntero. Cuando se quiere remplazar una página se siguen los siguientes pasos:",
                        "text_2_1": "Se busca una página con los bits de acceso y modificación desactivados, sin avanzar el puntero. Si se encuentra, esta es la página que se tiene que eliminar.",
                        "text_2_2": "En caso de no encontrar una página, buscar una página con el bit de acceso desactivado y el de modificación activado. Mientras se avanza el puntero, se desactiva el bit de acceso de la página."
                    }
                }
            }
        }
    }
}