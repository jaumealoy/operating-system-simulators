{
    "common": {
        "close": "Cerrar",
        "buttons": {
            "simpleview": "Vista simple",
            "comparaisonview": "Vista comparativa",
            "tutorial": "Tutorial",
            "previous_step": "Paso anterior",
            "next_step": "Siguiente paso",
            "reset": "Borrar datos",
            "pause": "Pausar",
            "play": "Iniciar",
            "stop": "Reiniciar simulación",
            "load_file": "Cargar simulación",
            "save_file": "Guardar simulación",
            "add": "Añadir",
            "save": "Guardar",
            "save_simulation": "Guardar simulación"
        },
        "example_number": "Ejemplo {{number}}",
        "examples": "Ejemplos",
        "simulation_algorithm": "Algoritmo simulación",
        "simulator_settings": "Configuración del simulador",
        "simulator_results": "Resultados",
        "tutorial": {
            "control_bar_overview": "Esto es la barra de control del simulador que te permite controlar la simulación.",
            "control_bar_reset": "Este botón reinicia el simulador: elimina todas las peticiones.",
            "control_bar_stop": "Este botón reinicia la simulación, sin eliminar las peticiones.",
            "control_bar_previous_step": "Este botón permite volver al estado anterior de la simulación",
            "control_bar_next_step": "Este botón avanza en un paso la simulación, permite ver la simulación paso a paso.",
            "control_bar_play": "Este botón permite iniciar o parar la simulación automática.",
            "control_bar_speed": "Puedes ajustar la velocidad de la simulación automática con esta barra",
            "view_bar": "Puedes cambiar entre una vista de un solo simulador y una vista de múltiples simuladores para realizar comparaciones.",
            "storage": "Puedes guardar y cargar las configuraciones de tu simulador.",
            "repeat_tutorial": "Puedes volver a ver este tutorial en cualquier momento pulsándome."
        },
        "filename": "Nombre del archivo",
        "filename_text": "El nombre del archivo solo puede contener carácteres alfanuméricos."
    },

    "io": {
        "requests": "Peticiones",
        "add_request": "Añadir petición",
        "no_requests_added": "No se ha introducido ninguna petición.",
        "track": "Pista",
        "direction": "Sentido",
        "upwards": "Ascendente",
        "downwards": "Descentende",
        "initial_position": "Posición inicial",
        "final_position": "Posición final",
        "track_number": "Número de pistas",
        "request_number": "# petición",
        "displacement": "Desplazamiento",
        "results": "Resultados",
        "total": "Total",
        "average": "Media",
        "time": "tiempo",
        "no_requests_completed": "No se ha completado ninguna petición",
        "algorithms": {
            "fcfs": "First Come First Served (FCFS)",
            "sstf": "Shortest Seek Time First (SSTF)",
            "scan": "SCAN",
            "cscan": "CSCAN",
            "look": "LOOK",
            "clook": "CLOOK"
        },

        "tutorial": {
            "algorithm_select": "Aquí puedes seleccionar el algoritmo de la simulación. Si estás en la vista comparativa podrás seleccionar más de uno.",
            "simulator_settings": "Puedes configurar el número de pistas y posición inicial del cabezal. También se puede indicar el sentido inicial del movimiento, si los algoritmos seleccionados lo permiten.",
            "request_list": "Aquí puedes indicar las peticiones que quieres simular y observar las peticiones que se procesarán",
            "request_list_add": "Para añadir una petición debes introducir un valor numérico entre {{min}} y {{max}} y pulsar el botón \"Añadir petición\".",
            "request_list_remove": "Aquí aparecen todas las peticiones así como las has introducido. Puedes borrarlas haciendo click en el icono con una \"X\"",
            "demo_requests": "El simulador ya incluye algunos ejemplos de peticiones para observar el funcionamiento de éste. Si pulsas sobre algún ejemplo se añadirán automáticamente las peticiones."
        }
    },

    "cpu": {
        "algorithms": {
            "fifo": "First In First Out (FIFO, FCFS)",
            "spn": "Shortest Process Next (SPN)",
            "srtn": "Shortest Remaining Time (SRT)",
            "hrrn": "Highest Response Ratio Next (HRRN)",
            "feedback": "Feedback",
            "rr": "Round Robin"
        },

        "quantum": "Quantum",
        "add_process": "Añadir proceso",
        "processes": "Procesos",
        "introduced_processes": "Procesos introducidos",
        "results": "Resultados",
        "timeline": "Línea temporal",
        "cpu": "Procesador",
        "no_process_running": "Actualmente no hay ningún proceso en ejecución.",
        "name": "Nombre",
        "cycle_distribution": "Distribución",
        "cycle_distribution_form": "Distribución de los ciclos",
        "incoming_processes": "Llegada de procesos",
        "remaining_cycles": "Ciclos restantes",
        "waiting_cycles": "Ciclos esperando",
        "waiting_time": "Tiempo esperando",
        "blocked": "Bloqueados",
        "ready": "Listos",
        "priority_number": "Prioridad {{value}}",
        "schedule_summary": "Resumen planificación",
        "process_already_exists": "Ya existe un proceso con este nombre",
        "arrival": "Llegada",
        "duration": "Ciclos",
        "value_equal_or_higher_than": "El valor debe ser igual o superior a {{value}}",
        "maximum_queues": "Máximo de colas",
        "zero_is_unlimited": "El valor 0 indica ilimitado",
        "fixed": "Fijo",
        "add_variant": "Añadir configuración",
        "process_list_empty": "No has introducido ninguna petición",
        "queue_empty": "No hay procesos en esta cola",
        "average": "Media",
        "variant_tag": {
            "unlimited_queues": "ilimitadas",
            "value_max_queues": "{{value}} colas"
        },
        "ratio": "Ratio",
        "summary": {
            "start": "Inicio",
            "end": "Finalización",
            "process": "Proceso",
            "service_time": "Tiempo de servicio",
            "turnaround_time": "Tiempo de retorno",
            "response_time": "Tiempo de respuesta",
            "normalized_response_time": "Tiempo de respuesta normalizado"
        },
        "tutorial": {
            "process_list": "Aquí puedes ver y eliminar los procesos que has introducido. Puedes ver su ciclo de llegada y su distribución de ciclos.",
            "summary_table": "Esta tabla muestra un resumen de la planificación de procesador. Cada fila es un proceso e indica información sobre su ejecución (llegada, finalización, tiempo de respuesta y de retorno).",
            "process_queues": "En el modo simple puedes ver en todo momento el estado de las colas. Los procesos están ordenados por orden de llegada: los elementos de arriba son los que han llegado primero.",
            "time_chart": "Este diagrama temporal muestra el estado del procesos (en ejecución o bloqueado) en cada ciclo de procesador.",
            "current_process": "También se muestra el estado actual del procesador y se muestra información del proceso en ejecución."
        }
    },

    "memory": {
        "allocation_menu": "Particiones variables",
        "pagination_menu": "Paginación",

        "allocation": {
            "capacity": "Capacidad (KB)",
            "current_cycle": "Ciclo actual:",
            "next_requests": "Próximas peticiones:",
            "process": "Proceso",
            "duration": "Duración",
            "end": "Finalización",
            "requested_memory": "Memoria solicitada (KB)",
            "permanent": "permanente",
            "not_enough_memory": "No hay memoria suficiente",
            "no_more_requests": "No hay más peticiones de memoria",
            "no_requests_completed": "No se ha atendido ninguna petición de memoria",
            "no_requests_added": "No se han añadido peticiones.",
            "completed_requests": "Peticiones de memoria atendidas:",
            "assigned_block": "Partición asignada",
            "cycle": "Ciclo",
            "memory": "Memoria",

            "algorithms": {
                "first_fit": "Primer ajuste (First fit)",
                "next_fit": "Siguiente ajuste (Next fit)",
                "worst_fit": "Peor ajuste (Worst fit)",
                "best_fit": "Mejor ajuste (Best fit)",
                "buddy": "Sistema de colegas (Buddy system)"
            }
        },

        "pagination": {
            "frames": "Marcos",
            "frame": "Marco",
            "processes_pages": "Páginas y procesos",
            "page_failures": "Fallos de página",
            "process_name": "Proceso {{name}}",
            "page": "Página",
            "last_access": "Último acceso",
            "select_algorithm": "Selecciona un algoritmo o más para utilizar la vista comparativa",
            "write": "Escritura",
            "added_requests": "Peticiones introducidas",
            "name_frames": "Nombre y marcos",
            "no_processes": "No has introducido ningún proceso",

            "algorithms": {
                "optimal": "Óptimo",
                "fifo": "First In First Out",
                "lru": "Least Recently Used",
                "clock": "Reloj",
                "nru": "Not Recently Used"
            },

            "access_bit": "Bit de acceso o referencia",
            "modified_bit": "Bit de modificación o dirty bit"
        },

        "tutorial": {
            "text_1": "El simulador de memoria está formado por el simulador de particiones variables y paginación. Para cambiar entre los simuladores puedes usar estos botones.",
            "text_2": "En el simulador de particiones variables puedes configurar la capacidad de la memoria y el algoritmo de la simulación.",
            "text_3": "Para añadir peticiones de memoria debes introducir un nombre único, la duración del proceso, la memoria solicitada y el instante de llegada.",
            "text_4": "Los resultados son un gráfico de la memoria y una tabla resumen de cada proceso.",

            "text_5": "En el simulador de paginación solo puedes seleccionar el algoritmo de la simulación, el número de marcos se calculará automáticamente a partir de los procesos.",
            "text_6": "Para utilizar el simulador de paginación, primero debes introducir los procesos y el número de marcos que tendrán asignados",
            "text_7": "A continuación puedes añadir la solicitudes de páginas de cada uno de los procesos. También puedes indicar si la petición modifica la página accedida.",
            "text_8": "El resultado del simulador es una visión general de la memoria y el estado de las páginas de cada proceso.",
            "text_9": "De cada proceso puedes visualizar su tabla de páginas y la evolución de ésta a lo largo del tiempo. Si el algoritmo lo permite, se visualiza el puntero con una casilla de color diferente"
        }
    },

    "menu": {
        "IOSimulator": "Simulador E/S",
        "CPUSimulator": "Simulador CPU",
        "MemorySimulator": "Simulador memoria",
        "FAQ": "Ayuda"
    },

    "help": {
        "modals": {
            "io": {
                "fcfs": {
                    "text_1": "El algoritmo First Come First Served procesa los accesos a disco secuencialmente. La primera petición que se recibe es la primera petición procesada.",
                    "text_2": "Al realizarse muchas peticiones, este algoritmo se comporta como una planificación aleatoria, aunque es el sistema más justo de todos."
                },

                "sstf": {
                    "text_1": "El algoritmo Shortest Seek Time First conocido como “primero con el tiempo de búsqueda menor” atiende primero aquellas peticiones que se encuentran más cerca del cabezal.",
                    "text_2": "Este sistema favorece las peticiones que se encuentran cerca del cabezal, desfavoreciendo las peticiones periféricas."
                },

                "scan": {
                    "text_1": "El algoritmo SCAN intenta simular el comportamiento de un ascensor. El cabezal se mueve desde la primera pista, aunque no haya peticiones, hasta la última procesando las peticiones que se encuentra. Cuando llega a un extremo, realiza el mismo recorrido en sentido contrario.",
                    "text_2": "El objetivo del algoritmo es reducir los cambios de sentido, pero favorece a las peticiones recientes."
                },

                "cscan": {
                    "text_1": "El algoritmo C-SCAN intenta simular el comportamiento de un ascensor como el algoritmo SCAN. El cabezal se mueve en un único sentido (ascendente o descendente) y cuando llega a un extremo se sitúa rápidamente al contrario sin atender peticiones.",
                    "text_2": "El principal objetivo es eliminar la discriminación entre las pistas interiores y las periféricas."
                },

                "look": {
                    "text_1": "El algoritmo LOOK simula el comportamiento de un ascensor. Este algoritmo procesa todas las peticiones que se encuentra en un sentido hasta llegar a la última pista. Luego realiza el mismo recorrido pero en sentido contrario hasta llegar a la última petición, sin llegar al extremo del disco.",
                    "text_2": "La principal diferencia entre LOOK y SCAN es que el primero no llega hasta los límites del disco, en cambio, SCAN sí."
                },

                "clook": {
                    "text_1": "El algoritmo C-LOOK tiene un comportamiento similar al LOOK. Este algoritmo siempre atiende todas las peticiones que se encuentra en un sentido, y siempre es el mismo. A diferencia del C-SCAN, éste no llega a los extremos del disco, solo hasta la pista con peticiones."
                }
            },

            "cpu": {
                "fifo": {
                    "text_1": "El algoritmo First In First Out (FIFO), también conocido como First Come First Served (FCFS) o “primero en llegar, primero servirse”, es la política de planificación más simple.",
                    "text_2": "Esta política de planificación consiste en ejecutar los procesos en el mismo orden que llegan a la cola de procesos listos.",
                    "text_3": "Así, si un proceso en ejecución queda bloqueado por E/S, cuando finalice la E/S, será el último de la cola de procesos listos y por tanto, el último en ejecutarse.",
                    "text_4": "Este algoritmo facilita la ejecución de procesos de larga duración y favorece aquellos limitados por el procesador."
                },

                "spn": {
                    "text_1": "El algoritmo Shortest Process Next (SPN) o “primero el más corto” es una política de planificación que consiste en ejecutar el proceso que se espera que sea más corto.",
                    "text_2": "Algunos inconvenientes de esta política es la necesidad de poder estimar la duración del proceso y la posible inanición de los procesos más largos que seran menos prioritarios frente los procesos cortos.",
                    "text_3": "En el simulador, el valor de la estimación es el número de ciclos del proceso."
                },

                "srtn": {
                    "text_1": "El algoritmo Shortest Remaining Time (SRT) es la versión apropiativa del algoritmo SPN que consiste en ejecutar el proceso con un tiempo restante de ejecución menor.",
                    "text_2": "El tiempo restante de un proceso se puede calcular a partir del número de ciclos que ha sido ejecutado y el tiempo de servicio, o en su defecto su estimación, del proceso.",
                    "text_3": "Este sistema de planificación puede producir inanición y favorece los procesos cortos frente a los procesos más largos."
                },

                "hrrn": {
                    "text_1": "El algoritmo Highest Response Ratio Next (HRRN) o “primero el de mayor tasa de respuesta” es un algoritmo no apropiativo que ejecuta el proceso con la mayor tasa de respuesta.",
                    "text_2": "Para cada uno de los procesos en la cola de listos se calcula su tasa de respuesta siguiendo la siguiente fórmula:",
                    "text_3": "Y se selecciona el proceso que maximice este resultado.",
                    "text_4": "En un principio favorece los procesos cortos, pero evita la inanición de los procesos largos porque se tiene en cuenta su tiempo de espera."
                }, 

                "rr": {
                    "text_1": "El algoritmo Round Robin o turno rotatorio es un algoritmo apropiativo basado en un reloj. Los procesos reciben un tiempo limitado, conocido como quantum, de procesador de manera rotatoria hasta que finalizan. Si los procesos han consumido el tiempo asignado y no han finalizado, son expulsados y vuelven a situarse al final de la cola de procesos listos.",
                    "text_2": "Los principales inconvenientes de este sistema son fijar una rodaja de tiempo adecuada, el bajo rendimiento de los procesos limitados por E/S y la sobrecarga que supone cambiar de proceso."
                },

                "feedback": {
                    "text_1": "El algoritmo Feedback o retroalimentación es un sistema apropiativo que hace uso de un sistema de colas de prioridad dinámica y un sistema de rodajas de tiempo. ",
                    "text_2": "Los procesos empiezan en la cola de máxima prioridad y cuando finaliza su rodaja de tiempo (y no han finalizado)  o quedan bloqueados por E/S pasan a la siguiente cola de menor prioridad.",
                    "text_3_1": "Por ejemplo, es habitual que la rodaja de tiempo sea una potencia de 2 de la forma ",
                    "text_3_2": ", donde i es la prioridad de la cola (i=0 es la cola más prioritaria).",
                    "text_4": "Este sistema da preferencia a los procesos cortos y penaliza los procesos largos que han estado mucho tiempo en ejecución, ya que se encuentran en colas de baja prioridad."
                }

            },

            "memory": {
                "allocation": {
                    "first_fit": {
                        "text_1": "El algoritmo First Fit o Primer ajuste asigna la primera partición disponible con la capacidad suficiente para almacenar el proceso, sin buscar si existen otros bloques de memoria más adecuados para la cantidad de memoria solicitada.",
                        "text_2": "Este sistema es el más rápido y sencillo que permite tener muchos procesos cargados al inicio de memoria entre los que se ha de encontrar un bloque libre."
                    },

                    "best_fit": {
                        "text_1": "El algoritmo Best Fit o Mejor ajuste asigna la partición más pequeña con capacidad suficiente para almacenar el proceso.",
                        "text_2": "El rendimiento global de este sistema no es tan bueno como el de otros sistemas y provoca mucha fragmentación externa, haciendo necesario compactar la memoria frecuentemente."
                    },

                    "next_fit": {
                        "text_1": "El algoritmo Next fit o Siguiente ajuste asigna el siguiente bloque de memoria con capacidad para almacenar el proceso a partir del último bloque de memoria asignado.",
                        "text_2": "Este sistema provoca fragmentación externa porqué el mayor bloque de memoria se encuentra al final de la memoria y éste se divide rápidamente en bloques más pequeños.",
                        "text_3": "Para su implementación, es necesario almacenar la posición del último bloque asignado."
                    },

                    "worst_fit": {
                        "text_1": "El algoritmo Worst fit o Peor ajuste asigna el mayor bloque de memoria con capacidad para el proceso con la intención de reducir la fragmentación."
                    },

                    "buddy": {
                        "text_1": "El sistema de colegas intenta lograr un equilibrio entre los sistemas de particiones fijas y los sistemas de particiones variables. Este sistema solo permite crear bloques de memoria de capacidad igual a una potencia en base 2.",
                        "text_2": "En un instante inicial, la memoria forma un único bloque de memoria, pero se puede ir dividiendo entre 2 para atender una petición de memoria. Los procesos ocupan un bloque de memoria óptimo, que es aquel con la capacidad mínima necesaria.",
                        "text_3": "Cuando se libera un bloque, el bloque liberado se puede fusionar con los bloques adyacentes siempre que sean descendentes del mismo bloque de potencia superior."
                    }
                },

                "pagination": {
                    "optimal": {
                        "text_1": "El algoritmo óptimo o mínimo es un algoritmo teórico que minimiza los fallos de página. Este algoritmo remplaza la página de un proceso que estará más tiempo en ser referenciada.",
                        "text_2": "En la práctica, es imposible de implementar ya que supondría conocer de antemano las páginas que van a ser referenciadas, cosa que no es posible."
                    },

                    "fifo": {
                        "text_1": "El algoritmo FIFO o \"primero en llegar primero en irse\" es un algoritmo que selecciona la página que más tiempo ha estado residiendo en la memoria, es decir, la página que ha llegado primero.",
                        "text_2": "Este algoritmo es fácil de implementar, pero hace un uso pobre de la localidad temporal, ya que es posible que una página se utilice frecuentemente y sea la primera en cargarse.",
                        "text_3": "Es posible pensar que si se aumentan el número de marcos asignados a cada proceso se reducirán el número de fallos de página. La anomalía de Belady explica que es posible que el número de fallos de página aumente si se incrementan el número de marcos asignados a cada proceso."
                    },

                    "lru": {
                        "text_1": "El algoritmo Least Recently Used (LRU) o \"menos usado recientemente\" hace uso del principio de localidad espacial para remplazar una página. La página remplazada es la que no ha sido referenciada desde hace más tiempo, que es la página que tiene menor probabilidad de ser referenciada en el futuro cercano.",
                        "text_2": "Este algoritmo se aproxima al algoritmo óptimo y es el que menos fallos de página genera. Para implementarlo es necesario etiquetar cada página en el instante en que es referenciada."
                    },

                    "clock": {
                        "text_1": "El algoritmo del reloj o de la segunda oportunidad intenta aprovechar el principio de temporalidad para elegir la página remplazada. Esto permite tener páginas muy utilizadas que han estado en la memoria durante mucho tiempo.",
                        "text_2": "Para implementar este algoritmo es necesario introducir un bit de acceso a la página, que se activa cuando se referencia una página, y un puntero, que indica la página candidata a ser eliminada. Cuando se quiere remplazar una página pueden darse dos casos:",
                        "text_2_1": "El puntero se encuentra en una página con el bit de acceso a 0. La página eliminada es la indicada por el puntero y se avanza el puntero.",
                        "text_2_2": "El puntero se encuentra en una página con el bit de acceso a 1. En este caso, se desactiva el bit de acceso y se avanza el puntero. El proceso se repite hasta encontrar una página con el bit de acceso a 0."
                    },

                    "nru": {
                        "text_1": "El algoritmo Not Recently Used o \"no usados recientemente\" es una mejora del algoritmo del reloj que hace uso del bit de escritura para evitar remplazar páginas que requieren escritura en la memoria secundaria.",
                        "text_2": "Para su implementación, además de los bits de acceso y modificación, se hace uso de un puntero. Cuando se quiere remplazar una página se siguen los siguientes pasos:",
                        "text_2_1": "Se busca una página con los bits de acceso y modificación desactivados, sin avanzar el puntero. Si se encuentra, esta es la página que se tiene que eliminar.",
                        "text_2_2": "En caso de no encontrar una página, buscar una página con el bit de acceso desactivado y el de modificación activado. Mientras se avanza el puntero, se desactiva el bit de acceso de la página."
                    }
                }
            }
        },

        "working": "Funcionamiento",
        "algorithms": "Algoritmos",

        "memory": {
            "management": "Gestión de memoria",
            "allocation": {
                "text_1": "El sistema de particiones variables consiste en asignar particiones de memoria de la dimensión necesaria para almacenar un proceso. Los procesos (o peticiones de memoria) se atienden según su orden de llegada. Una vez los procesos finalizan, se libera la partición asignada, dejando un hueco libre de memoria y creando fragmentación externa.",
                "text_2": "Para solventar los problemas de la fragmentación externa se debe compactar la memoria para maximizar el uso de la memoria, pero esta operación requiere dedicar ciclos de procesador. El algoritmo seleccionado para asignar las particiones de memoria puede influir en la cantidad de fragmentación externa generada.",
                "text_3": "El primer paso para utilizar el simulador es configurar la cantidad de memoria disponible. Para ello se debe introducir un valor entero en el campo de texto \"Capacidad\".",
                "text_4": "Para introducir peticiones se debe utilizar el formulario situado en la sección de “Peticiones” y rellenar los distintos campos de texto:",
                "text_4_1": "El nombre del proceso",
                "text_4_2": "La duración es el número de ciclos que el proceso estará en ejecución",
                "text_4_3": "La memoria es la cantidad de memoria que el proceso solicita",
                "text_4_4": "La llegada es el instante o ciclo en el cual el proceso se iniciará",
                "text_5": "Los resultados del simulador son un gráfico en el cual se puede observar la distribución de la memoria en todo momento y unas tablas resumen que indican qué particiones han ocupado cada uno de los procesos.",
                "text_6": "Si en un determinado instante no hay espacio suficiente para un proceso, éste quedará en la cola de procesos pendientes y tendrá prioridad sobre los demás procesos.",
                "text_7": "También se puede consultar el tutorial del simulador en la página del propio simulador."
            },

            "pagination": {
                "text_1": "La paginación es una técnica que intenta resolver el problema de la fragmentación externa permitiendo que un proceso no tenga que ocupar posiciones contiguas de la memoria.",
                "text_2": "La memoria física se divide en particiones o marcos de un tamaño fijo y la memoria lógica se divide en bloques o páginas del mismo tamaño que los marcos. Es necesario establecer una equivalencia entre las direcciones físicas y las direcciones lógicas, para ello se utiliza una tabla de páginas que contiene el número de marco asignado a cada página.",
                "text_3": "Los procesos no tienen, en general, todas sus páginas cargadas en la memoria principal. Cuando se quiere acceder a una página que no está cargada en la memoria principal se produce un fallo de página, que supone liberar un marco de la memoria principal para cargar la página solicitada. En función del algoritmo de remplazo utilizado se pueden minimizar los fallos de página producidos.",

                "text_4": "Una vez seleccionado el algoritmo de simulación solo se deben introducir los procesos y sus peticiones, el número de marcos de la memoria principal se obtiene a partir de los marcos que pueden estar asignados a los procesos.",
                "text_5": "Para añadir un proceso se debe introducir un nombre único y la cantidad de marcos que puede utilizar y pulsar icono \"+\".",
                
                "text_6": "Para añadir una petición se debe seleccionar el proceso que realiza la solicitud y la página que se quiere consultar. También se puede indicar si esta petición modifica o no la página utilizando la casilla de \"Escritura\".",
                
                "text_7": "Los resultados del simulador son una representación de la memoria física con los marcos y la página que tienen cargada. También para cada uno de los procesos se muestra la tabla de páginas y la evolución de esta en cada uno de los pasos."
            }
        },

        "cpu": {
            "title": "Planificación de CPU",
            "text_1": "El simulador de planificación de procesador permite observar el funcionamiento de los distintos algoritmos que se utilizan a la hora de poner en ejecución un proceso.",
			"text_2": "En la página del simulador se puede consultar el tutorial específico del simulador que realiza una visita guiada a las distintas funcionalidades del simulador.",
            
            "working": {
                "text_1": "Para empezar a utilizar el simulador es necesario introducir, como mínimo, un proceso. Para introducir un proceso se debe indicar:",
                "text_1_1": "El nombre del proceso, que debe ser único. Por defecto, se utilizará una letra disponible.",
                "text_1_2": "El ciclo de llegada.",
                "text_1_3": "La duración del proceso y la distribución de sus ciclos.",
                "text_1_4": "Se puede especificar si el proceso estará bloqueado por E/S o utilizando el procesador en cada uno de los ciclos.",
                "text_2": "También se puede cargar uno de los ejemplos del simulador, que carga una lista de procesos predeterminada.",
                "text_3": "Una vez introducidos los procesos, estos se pueden eliminar de la lista de procesos. Para eliminarlos se debe presionar el botón situado al lado del nombre del proceso en la lista de procesos.",
                
                "views_title": "Vista simple y comparativa",
                "text_4": "Si se está usando la “Vista simple” del simulador se puede seleccionar un único algoritmo. Los algoritmos que requieran configuración adicional mostrarán un panel al lado de la selección del algoritmo una vez seleccionados.",
                "text_5_1": "En cambio, si se está usando la “Vista comparativa” se pueden seleccionar los distintos algoritmos al mismo tiempo.",
                "text_5_2": "En este modo, es necesario crear configuraciones de aquellos algoritmos que lo requieran. Para hacerlo, primero se debe marcar el algoritmo y presionar el botón “Añadir” que aparece bajo su nombre. A continuación, se mostrará el panel de configuración del algoritmo. Para guardar la configuración se debe presionar el botón “Añadir configuración”.",
                "text_6": "Una vez iniciada la simulación no se pueden realizar cambios en la lista de procesos o características de los algoritmos. Para poder hacer cambios es necesario finalizar la simulación.",

                "results_title": "Resultados de la simulación",
                "time_chart_title": "Diagrama temporal",
                "text_7_1": "El diagrama temporal permite visualizar qué procesos se han ejecutado o han estado bloqueados por E/S en cada ciclo de la simulación.",
                "text_7_2": "Los distintos procesos se ordenan a lo largo del eje vertical según el orden de introducción en el simulador. El eje horizontal es el tiempo, expresado en ciclos de procesador.",

                "text_8_1": "En función del estado del proceso en cada unos de los ciclos se representa de la siguiente manera:",
                "text_8_2": "Con un color sólido, el proceso se estaba ejecutando en ese instante",
                "text_8_3": "Con un rectángulo rayado, el proceso estaba bloqueado por E/S en ese instante",
                "text_8_4": "Sin rectángulo, el proceso no estaba en ejecución ni bloqueado",

                "summary_table_title": "Tabla resumen",
                "text_9": "La tabla resumen de planificación muestra un resumen de cada uno de los procesos de la simulación. Para cada uno de ellos indica:",
                "text_9_1": "El ciclo de llegada del proceso.",
                "text_9_2": "El ciclo de inicio del proceso, cuando ha empezado a recibir tiempo de procesador.",
                "text_9_3": "El ciclo de finalización del proceso.",
                "text_9_4": "El tiempo de respuesta, que es el tiempo entre la llegada de un proceso y su inicio.",
                "text_9_5": "El tiempo de servicio",
                "text_9_6": "El tiempo de retorno ",
                "text_9_7": " que es el tiempo de espera más el tiempo de ejecución.",
                "text_9_8": "El tiempo de retardo normalizado calculado a partir de ",
                "text_10": "De las columnas tiempo de retorno y tiempo de retorno normalizado se muestra la media de sus valores."
            }
        },

        "io": {
            "title": "Planificación de E/S",
            "text_1": "El simulador de Entrada y Salida permite observar el funcionamiento de los algoritmos utilizados para atender a las peticiones de acceso a disco.",
            "hdd_parts": "Elementos de un disco duro",
            "text_2": "El disco duro es un dispositivo de almacenamiento que hace uso de las propiedades magnéticas de sus discos para almacenar información. El dispositivo se puede dividir en distintas partes: ",
            "text_2_1": "Los platos son cada uno de los discos donde se guarda la información bit a bit.",
            "text_2_2": "Estos platos están hechos de un material con unas propiedades magnéticas que permiten cambiar la orientación del campo magnético.",
            "text_2_3": "Las pistas son cada una de las divisiones radiales en el plato.",
            "text_2_4": "Las pistas se dividen en sectores, que son la unidad mínima de información. Los sectores situados más a la periferia tendrán una densidad de información inferior a los situados en pistas más interiores.",
            "text_2_5": "El cilindro es el conjunto de una pista en los distintos platos.",
            "text_2_6": "El cabezal es una pieza móvil que realiza la lectura o escritura de la información en los sectores. Esta pieza puede cambiar la orientación del campo magnético de los platos, en función de la información que se quiere escribir.",
         
            "working": {
                "text_1": "El simulador permite seleccionar entre los distintos algoritmos, la posición inicial del cabezal y la cantidad de pistas del disco.",
                "text_2": "Los algoritmos que requieren una configuración adicional como SCAN y LOOK (y sus variantes) permiten indicar el sentido inicial del recorrido.",
                "text_3": "Para añadir una petición al simulador, se debe introducir un valor numérico en el rango [0, número de pistas) y pulsar el botón \"Añadir petición\".",
                "text_4": "También se pueden eliminar las peticiones añadidas haciendo click en el icono de eliminar petición situado a la derecha del número de pista.",
                "text_5": "Los resultados del simulador son:",
                "text_5_1": "Un gráfico que muestra las distintas peticiones y cómo han sido atendidas. El eje horizontal representa el tiempo y el vertical el número de pista.",
                "text_5_2": "Una tabla con cada uno de los desplazamientos, indicando la posición inicial y final del desplazamiento."
            }
        },

        "about": {
            "title": "Sobre la aplicación",
            "text_1": "En esta sección puedes encontrar información sobre los propios simuladores y de los conceptos relacionados con ellos.",
            "text_2": "Esta aplicación ha sido desarrollada como Trabajo de Fin de Grado del Grado en Ingeniería Informática de la ",   
            "developed_by": "Aplicación desarrollada por ",
            "supervision": " con la supervisión de Adelaida Delgado Domínguez."
        }
    }
}